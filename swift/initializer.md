# 이니셜라이져 (Initializer)
초기화(initialization)는 클래스나 구조체 또는 열거형의 **인스턴스를 사용하기 위한 준비과정이다.** 초기화가 완료된 인스턴스는 사용 후 소멸 시점이 오면 소멸된다. 클래스의 이니셜라이저와 이니셜라이저 상속에 관한 부분은 [상속]()에서 다루도록 하겠습니다.

## 인스턴스의 생성
초기화 과정은 새로운 인스턴스가 사용될 준비를 하기위해 `저장 프로퍼티`의 초기값을 설정하는 등의 일을 수행한다. ++이니셜라이저(initializer)++를 정의하면 초기화 과정을 직접 구현할 수 있다. 이니셜라이저는 해당 타입의 새로운 인스턴스를 생성하기 위해 호출된다. 아래 코드는 매개변수가 없는 기본 이니셔라이저의 모습이다. 이니셜라이저는 `init` 키워드를 사용하여 이니셜라이저 메소드임을 표현한다. `init`메서드는 클래스, 구조체, 열거형 등의 구현부 또는 그 타입의 익스텐션 구현부에 위치한다.++(단, 클래스의 지정 이니셜라이저는 익스텐션에서 구현해 줄 수 없다.)++ 

```swift
class SomeClass {
	init() {
		// 초기화 시 필요한 코드
	}
}

struct SomeStruct {
	init() {
		// 초기화 시 필요한 코드
	}
}

enum SomeEnum {
	case someCase 

	init() {
		// 열거형은 초기화 시 반드시 케이스중 하나가 되어야 한다.
		self = .someCase
		// 초기화 시 필요한 코드
	}
}
```

### 프로퍼티 기본값
구조체와 클래스의 인스턴스는 처음 생성될 떄 옵셔널 저장 프로퍼티를 제외한 모든 저장 프로퍼티에 적적한 **초기값(Initial Value)**이 할당되어야 한다. 프로퍼티를 정의할 때 프로퍼티 **기본값(Default Value)**을 할당하면 이니셜라이저에서 따로 초기값을 할당하지 않아도 프로퍼티 기본값으로 저장 프로퍼티의 값이 초기화 된다. 

> **초기화와 프로퍼티 감시자**
> 이니셜라이저를 통해 초기값을 할당하거나, 프로퍼티 기본값을 통해 처음의 저장 프로퍼티가 초기화될 때에는 프로퍼티 감시자 메소드가 호출되지 않는다. 

```swift
struct Area {
	var squareMeter: Double

	init() {
		squareMeter = 0.0	// squareMeter의 초기값 할당
	}
}

let room: Area = Area()
print(room.squareMeter)		// 0.0
```
위의 코드처럼 이니셜라이저로 저장 프로퍼티에 초깃값을 설정할 수도 있지만, 아래와 같이 프로퍼티를 정의할 때 프로퍼티에 기본값을 할당하는 방식을 사용할 수도 있다.

```swift
struct Area {
	var squareMeter: Double = 0.0	// 프로퍼티 기본값 할당
}

let room: Area = Area()
print(room.squareMeter)	// 0.0
```

### 이니셜라이저 매개변수
함수나 메소드를 정의할 때와 마찬가지로 이니셜라이저도 매개변수를 가질 수 있다. 즉, 인스턴스를 초기화하는 과정에 필요한 값을 전달받을 수 있다. 이렇게 사용자정의 이니셜라이저를 만들면 기존의 기본 이니셜라이저 `init()`은 별도로 구현하지 않는 이상 사용할 수 없다. 

### 옵셔널 프로퍼티 타입 
초기화 과정에서 값을 초기화하지 않아도 되는, 즉 인스턴스가 사용되는 동안에 값을 꼭 가지지 않아도 되는 또는 초기화되는 과정에서 값을 지정해주기 어려운 경우의 저장 프로퍼티가 있다면 해당 프로퍼티를 옵셔널로 선언할 수 있다. 옵셔널로 선언된 저장 프로퍼티는 초기화 과정에서 값을 할당해주지 않는다면 자동적으로 `nil`이 할당된다. 

### 상수 프로퍼티 
상수로 선언된 저장 프로퍼티는 인스턴스를 초기화하는 과정에서만 값이 할당될 수 있으며, 처음 할당된 이후로는 값을 변경할 수 없다. 
> **상수 프로퍼티와 상속**
> 클래스 인스턴스의 상수 프로퍼티는 프로퍼티가 정의된 그 클래스에서만 초기화될 수 있다. 그 ++클래스를 상속받은 자식클래스의 이니셜라이저에서는 부모의 상수 프로퍼티 값을 초기화할 수 없다. ++

### 기본 이니셜라이저와 멤버와이즈 이니셜라이저
사용자정의 이니셜라이저를 정의해주지 않으면 클래스나 구조체는 모든 프로퍼티에 기본값이 지정되어 있다는 전제하에 기본 이니셜라이저를 사용한다. 기본 이니셜라이저는 저장 프로퍼티의 기본값이 모두 지정되어 있고, 동시에 사용자정의 이니셜라이저가 정의되어 있지 않은 상태에서 제공된다. 구조체는 사용자정의 이니셜라이저를 구현하지 않으면 프로퍼티의 이름으로 매개변수를 가지는 이니셜라이저인 멤버와이즈 이니셜라이저를 기본으로 제공한다. 그렇지만 클래스는 멤버와이즈 이니셜라이저를 지원하지 않는다. 아래는 구조체의 멤버와이즈 이니셜라이저의 사용 예시이다.
```swift
struct Point {
	var x: Double = 0.0
	var y: Double = 0.0
}

let point: Point = Point(x: 0, y: 0)
```

### 초기화 위임
값 타입인 구조체와 열거형은 코드의 중복을 피하기 위하여 이니셜라이저가 다른 이니셜라이저에게 일부 초기화를 위임하는 초기화 위임을 간단하게 구현할 수 있다. 하지만 클래스는 상속을 지원하기 때문에 간단한 초기화 위임을 할 수 없다. 값 타입에서 이니셜라이저가 다른 이니셜라이저를 호출하려면 `self.init`을 사용한다. 이니셜라이저 안에서 `self.init`을 사용한다는 것 자체가 사용자정의 이니셜라이저를 정의하고 있다는 뜻이다. 사용자정의 이니셜라이저를 정의하면 기본 이니셜라이저와 멤버와이즈 이니셜라이저를 사용할 수 없다. 따라서 초기화 위임을 하려면 최소 두 개 이상의 사용자정의 이니셜라이저를 정의해야 한다.
> **기본 이니셜라이저를 지키고 싶다면**
> 사용자정의 이니셜라이저를 정의할 때에도 기본 이니셜라이저나 멤버와이즈 이니셜라이저를 사용하고 싶다면 익스텐션을 사용하여 사용자정의 이니셜라이저를 구현하면 된다.  

```swift
enum Student {
	case elementary, middle
	case none

	// 사용자정의 이니셜라이저가 있는 경우, init() 메소드를 구현해주어야 기본 이니셜라이저를 사용할 수 있다. 
	init() {
		self = .none
	}

	init(koreanAge: Int) {	// 첫 번째 사용자정의 이니셜라이저
		switch koreanAge {
			case 8... 13: 
				self = .elementary
			case 14... 16:
				self = .middle
			default: 
				self = .none
		}
	}

	init(bornAt: Int, currentYear: Int) {	//  두 번째 사용자정의 이니셜라이저
		self.init(koreanAge: currentYear - boenAt + 1)	// 첫 번째 사용자정의 이니셜라이저 호출 
	}
}
```
위의 열거형은 두 개의 사용자정의 이니셜라이저를 가지고 있다. 이렇게 초기화 위임 방법을 사용하면 코드를 중복으로 사용하지 않고도 효율적으로 여러 케이스의 이니셜라이저를 만들 수 있다. 

### 실패 가능한 이니셜라이저
이니셜라이저를 정의할 때 실패 가능성을 염두에 두기도 하는데, 이렇게 실패 가능성을 내포한 이니셜라이저를 **실패 가능한 이니셜라이저(Failable Initializer)**라고 부른다. 실패 가능한 이니셜라이저는 클래스, 구조체, 열거형 등에 모두 정의할 수 있다. 실패 가능한 이니셜라이저는 실패하였을 때 `nil`을 반환해주므로 반환 타입이 옵셔널로 지정된다. 따라서 실패 가능한 이니셜라이저는 **init대신에 init? 키워드를 사용한다.**

> **이니셜라이저의 매개변수**
> 실패하지 않는 이니셜라이저와 실패 가능한 이니셜라이저를 같은 이름과 같은 매개변수 타입을 갖도록 정의할 수 없다. 실패 가능한 이니셜라이저가 실제로는 특정 값을 반환하지 않는다. 다만, 초기화를 실패했을 때는 return nil을, 반대로 초기화에 성공했을 때는 return 을 적어 초기화의 성공과 실패를 표현할 뿐, 실제 값을 반환하지는 않는다. 
```swift
class Person {
	let name: String
	var age: Int?

	init?(name: String) {
		if name.isEmpty {
			return nil
		}
		self.name = name
	}

	init?(name: String, age: Int) {
		if name.isEmpty || age < 0 {
			return nil
		}
		self.name = name
		self.age = age
	}
}
```

### 함수를 사용한 프로퍼티 기본값 세팅
만약 사용자정의 연산을 통해 저장 프로퍼티 기본값을 설정하고자 한다면 클로저나 함수를 사용해 프로퍼티 기본값을 제공할 수 있다. 인스턴스가 초기화될 때 함수나 클로저가 호출되면서 연산을 통한 결괏값을 프로퍼티 기본값으로 제공해준다. 단, 클로저 내부에서는 인스턴스의 다른 프로퍼티를 사용하여 연산할 수 없다. 프로퍼티 기본값을 세팅해주기 위해 클로저가 실행되어야 할 시점은 아니셜라이즈(초기화)될 때 즉, 인스턴스의 다른 프로퍼티의 값이 세팅되기 전이기 때문이다. 다른 프로퍼티가 기본값을 가지고 있다고 해도 안된다. 또한, 클로저 내부에서 self 프로퍼티도 사용할 수 없으며, 인스턴스 메소드를 호출할 수도 없다.

```swift
class SomeClass {
	let someProperty: SomeType = {
		// 새로운 인스턴스를 생성하고 사용자정의 연산을 통한 후 반환해준다.
		// 반환되는 값의 타입은 SomeType과 같은 타입이어야 한다.
		return someValue
	}()	// 클로저 실행위해 소괄호를 붙인다. 없다면, 클로저 그 자체가 프로퍼티의 기본값!
}
```


```swift
struct Student {
	var name: String?
	var number: Int?
}

class SchoolClass {
	var students: [Student] = {	// [Student] 타입의 반환 값
		// 새로운 인스턴스를 생성하고 사용자정의 연산을 통한 후 반환해준다.
		// 반환되는 값의 타입은 [Student] 타입이어야 한다.

		var arr: [Student] = [Student]()

		for num in 1...15 {
			var student: Student = Student(name: nil, number: num)
			arr.append(student)
		}

		return arr
	}()		// 클로저 실행
}

let myClass: SchoolClass = SchoolClass()
print(myClass.students.count)	//15
```

> **TIP. iOS에서의 활용**
> 스위프트 언어와는 크게 관계가 없지만 iOS의 UI등을 구성할 때, UI 컴포넌트를 클래스의 프로퍼티로 구현하고, UI 컴포넌트의 생성과 동시에 컴포넌트의 프로퍼티를 기본적으로 세팅할 때 유용하게 사용할 수 있다. 








