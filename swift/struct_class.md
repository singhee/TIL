# 구조체와 클래스
구조체와 클래스는 프로퍼티와 메소드를 사용하여 구조화된 데이터와 기능을 가짐으로써 하나의 **새로운 사용자정의 데이터 타입**을 만들어 준다. 스위프트에서는 구조체와 클래스의 모습과 문법이 거의 흡사하다. 다만, 구조체의 인스턴스는 **값 타입**이고, 클래스의 인스턴스는 **참조 타입**이라는 것이 이 둘을 구분하는 가장 큰 차이점이다. 스위프트에서는 소스파일 하나에 여러 개의 구조체와 여러 개의 클래스를 정의하고 구현해도 문제가 없다. 또한, 중첩 함수와 마찬가지로 구조체 안에 구조체, 클래스 안에 클래스 등과 같이 중첩 타입의 정의 및 선언이 가능하다. 

## 구조체 
구조체 정의와 인스턴스 생성, 그리고 구조체의 활용 방법에 대해 알아보도록 하자.

### 구조체 정의
구조체는 `struct`키워드로 정의한다. 

> **구조체 명명법**
> 구조체를 정의한다는 것은 새로운 타입을 생성해주는 것과 마찬가지이므로 기본 타입(Int, String, Bool)처럼 대문자를 사용하여 이름을 지어주도록 한다. 마찬가지로 프로퍼티와 메소드는 소문자를 사용하여 이름을 지어준다.

```swift
struct 구조체 이름 {
	프로퍼티와 메소드들
}


struct BasicInformation{
	var name: String
	var age: Int
}
```

### 구조체의 인스턴스 생성 및 초기화
구조체의 정의 후, 구조체의 인스턴스를 생성하고 초기화하고자 할 때에는 기본적으로 생성되는 ++멤버와이즈 이니셜라이저++를 사용한다. **구조체에 기본 생성된 이니셜라이저의 매개변수는 구조체의 프로퍼티 이름으로 자동 지정된다.** 기본으로 제공되는 멤버와이즈 이니셜라이저 외에 사용자정의 이니셜라이저도 구현이 가능하다. 

```swift
// 프로퍼티 이름 (name, age)으로 자동 생성된 initializer를 사용하여 구조체를 생성한다.
var sangheeInfo: BasicInformation = BasicInformation(name: "sanghee", age: 23)
sangheeInfo.age = 100				// 프로퍼티 값 접근은 마침표(.)를 사용
sangheeInfo.name = "sanghee Yoon"	// 구조체와 내부 프로퍼티가 모두 var로 선언되었기 때문에 값 변경 가능!

// 프로퍼티 이름 (name, age)으로 자동 생성된 initializer를 사용하여 구조체를 생성한다.
let singheeInfo: BasicInformation = BasicInformation(name: "singhee", age: 23)
singheeInfo.age = 100	// 구조체가 상수 let으로 선언되었기 때문에 값 변경 불가!
```

## 클래스 
클래스의 정의와 인스턴스 생성, 그리고 클래스의 활용 방법에 대해 알아보도록 하자. 스위프트의 클래스는 부모클래스가 없더라도 상속 없이 단독으로 정의가 가능하다. 

### 클래스 정의
클래스를 정의할 때에는 `class`키워드를 사용한다.

> **클래스 명명법**
> 클래스를 정의하는 방법은 구조체와 흡사하다. 다만, 클래스는 상속받을 수 있기 때문에 상속받을 때에는 클래스 이름 뒤에 콜론(:)을 써주고 부모클래스 이름을 명시한다.

```swift
class 클래스 이름 {
	프로퍼티와 메소드들
}

class 클래스 이름: 부모클래스 이름 {	// 상속받는 경우
	프로퍼티와 메소드들
}

class Person {
	var height: Float = 0.0
	var weight: Float = 0.0
}
```

### 클래스 인스턴스의 생성과 초기화
클래스를 정의한 후, 클래스의 인스턴스를 생성하고 초기화하고자 할 때에는 기본적인 initializer를 사용한다. 위에서 정의한 Person 클래스에서는 프로퍼티의 기본값이 지정되어 있어 initializer의 전달인자를 통해 따로 초기값을 전달해주지 않아도 된다. 구조체와 마찬가지고 기본 initializer 외에 사용자가 직접 initializer를 정의할 수도 있다. 

> **인스턴스와 객체**
> 보통 객체지향 프로그래밍 패러다임을 지향하는 언어에서는 클래스의 인스턴스를 객체라고 통칭한다. 스위프트에서도 객체라고 표현하는 것이 틀린 것은 아니지만, 스위프트 공식 문서에는 좀 더 한정적인 인스턴스라는 용어를 사용한다. 

인스턴스가 생성되고 initialize된 후 프로퍼티 값에 접근하고 싶다면 마침표(.)를 사용하면 된다. **구조체와는 다르게 클래스의 인스턴스는 `참조 타입`이므로 클래스의 인스턴스를 상수 `let`으로 선언해도 내부 프로퍼티 값을 변경할 수 있다.** 

```swift
var sanghee: Person = Person()
sanghee.height = 123.4
sanghe.weight = 123.4

let singhee: Person = Person()
singhee.height = 123.4
singhee.weight = 123.4
```

### 클래스 인스턴스의 소멸
클래스의 인스턴스는 `참조 타입`이므로 더이상 참조할 필요가 없을 때 메모리에서 해제 된다. (메모리에서 해제되는 시점에 대해서는 ARC 참조.) 
이 과정을 **소멸**이라고 칭하는데, 클래스 내부에서 `deinit`메소드를 구현해주면 소멸되기 직전에 이 메소드가 호출된다. 이렇게 호출되는 `deinit`메소드는 다음과 같이 4가지 특성을 가지고 있다. 
```
deinit 메소드
1. 디이니셜라이저(Deinitializer) 라고 부른다.
2. 클래스당 하나만 구현할 수 있다.
3. 매개변수와 반환 값을 가질 수 없다.
4. 매개변수를 위한 소괄호도 적어주지 않는다.
```

``` swift
class Person {
	var height: Float = 0.0
	var weight: Float = 0.0

	deinit {
		print("Person 클래스의 인스턴스가 소멸됩니다.")
	}
}

var sanghee: Person? = Person()
sanghee = nil	// Person 클래스의 인스턴스가 소멸된다. 
				// Optinal로 선언된 인스턴스는 nil을 할당하여 deinitialize 호출하는데, 클래스의 인스턴스가 Optional로 선언되지 않았을 경우에는 다른 참조로 변경하는 순간 deinitialize 호출한다.
```
보통 `deinit`메소드에는 인스턴스가 메모리에서 해제되기 직전에 처리할 코드를 넣어준다. 예를 들어 인스턴스를 소멸 전에 데이터를 저장한다거나 다른 객체에 인스턴스 소멸을 알려야 할 때 구현해야 한다. 

## 구조체와 클래스의 차이 
구조체와 클래스는 겉보기엔 정의하는 방법도, 인스턴스화하는 방법도, 프로퍼티와 메소드를 갖는다는 점등 많은 부분에서 비슷해 보인다. 그러나 이 두 타입을 구분 짓는 가장 큰 차이점은 **값 타입**과 **참조 타입**이라는 것이다. 아래는 구조체와 클래스의 같은 점과 다른 점에 대해 정리한 것이다. 

#### 같은 점
- 값의 저장과 기능 수행을 위해 프로퍼티와 메소드를 정의할 수 있다.
- 서브스크립트 문법을 통해 구조체 또는 클래스가 가지는 값(프로퍼티)에 접근하도록 서브스크립트를 정의할 수 있다.
- 초기화될 때 상태를 지정하기 위해 `initializer`를 정의할 수 있다.
- 초기구현과 더불어 새로운 기능 추가를 위해 `extension` 통해 확장할 수 있다. 
- 특정 기능을 수행하기 위해 특정 프로토콜을 준수할 수 있다. 

#### 다른 점
- 구조체는 상속할 수 없다.
- Type Casting은 클래스의 인스턴스에만 허용된다.
- deinitializer는 클래스의 인스턴스에만 활용할 수 있다. 
- Reference Counting은 클래스의 인스턴스에만 적용된다. 

### 값 타입과 참조 타입
값 타입 | 참조 타입
-----------|-----------
구조체 | 클래스
함수의 전달인자로 넘기거나, 다른 변수/상수에 할당할 때 값이 복사된다 | 함수의 전달인자로 넘기거나, 다른 변수/상수에 할당할 때 참조(주소)가 전달된다
메모리에 전달인자를 위한 인스턴스가 새로 생성되어 전달된다 | 기존 인스턴스의 참조가 전달되므로 기존의 인스턴스 참조가 전달된다

클래스의 인스턴스끼리 참조가 같은지 확인하려면 `식별 연산자(Identity Operation)`를 사용한다. 식별연산자를 사용하여 두 참조가 같은 인스턴스를 가리키고 있는지 비교해보는 코드는 아래와 같다.
```swift
var sanghee: Person = Person()
let friend: Person = sanghee 			// sanghee의 참조를 할당
let anotherFriend: Person = Person()	// 새로운 인스턴스 생성

print(sanghee === friend)				// true
print(sanghee === anotherFriend)		// false
print(friend !== anotherFriend)			// true
```

### 스위프트의 기본 데이터 타입은 모두 구조체이다.
```swift
 public struct String {
 	// An empty 'String'
 	public init()
 }
```
위의 코드는 스위프트 표준 라이브러리에 포함되어 있는 스위프트의 String타입의 기본정의 코드이다. 이처럼 스위프트의 다른 기본 타입(Bool, Int, Array, Dictionary, Set...)도 String 타입과 마찬가지로 모두 구조체로 구현되어 있다. 이것은 **기본데이터 타입은 모두 값 타입**이라는 뜻을 의미한다. 전달인자를 통해 데이터를 전달하면 모두 값이 복사되어 전달될 뿐, 함수 내부에서 아무리 전달된 값을 변경해도 기존의 변수나 상수에는 전혀 영향을 미치지 못한다는 의미이다. 

## 구조체와 클래스 선택해서 사용하기 
구조체의 인스턴스는 항상 값 타입이고, 클래스 인스턴스는 참조 타입이다. 이는 용도가 다르기 때문에 상황에 따라 잘 선택해서 사용해야 된다는 것을 의미한다. 프로젝트의 성격에 따라, 데이터의 활용에 따라, 특정 타입을 구현할 때 구조체와 클래스 둘 중 하나를 선택해서 사용해야 된다. 

애플에서는 다음 조건 중 하나 이상에 해당되면 구조체를 사용하기를 권장하는 가이드라인을 세웠다.
```
1. 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
2. 캡슐화된 값이 참조되는 것보다 복사되는 것이 합당할 때
3. 구조체에 저장된 프로퍼티가 값 타입이며 참조되는 것보다 복사되는 것이 합당할 때
4. 다른 타입으로부터 상속받거나 자신이 상속될 필요가 없을 때
```
대다수 사용자정의 데이터 타입은 구조체 보다는 클래스로 구현할 일이 더 많을 수 있다. 
























