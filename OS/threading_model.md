# Threading Model
스레드의 구현은 운영체제에 따라 다양하다. 대부분의 운영체제는 세 가지 중 한 가지 스레딩 모델을 구현한다.

## 1. 사용자 수준 스레드
​사용자 수준 스레드(user-level thread)​는 사용자 영역에서 스레드 연산을 수행한다.
특권 명령을 실행할 수 없거나 커널 프리미티브에 직접 접근할 수 없는 런타임 라이브러리가 스레드를 생성한다.
사용자 수준 스레드는 운영체제에 투명하다.
​운영체제는 각 스레드가 아닌 멀티스레드를 포함하는 프로세스 한 단위를 대상으로 프로세서를 할당한다. 이 때문에 사용자 수준 스레드 구현을 ​다대일 스레드 맵핑(​many-to-one thread mapping)​이라고도 한다.
​
프로세스가 사용자 수준 스레드를 사용할 때는 사용자 수준 라이브러리로 프로세스의 스레드를 스케줄링하고 디스패치한다. 멀티스레드 프로세스는 자신에 할당된 퀀텀이 만료되거나, 다른 이유 때문에 커널에 프로세서를 선점당할 때까지 실행을 계속한다.

### 1-1. 장점
​​1) ​운영체제에서 스레드를 지원할 필요가 없다. API에 의존하지 않고, 이식성이 높아진다.
​2) 스레딩 라이브러리에서​​ ​스레드 스케줄링을 제어하기 때문에, 응용 프로그램 개발자들이 자신의 응용 프로그램 요구에 맞게 스레딩 라이브러리의 스케줄링 알고리즘을 수정할 수 있다는 점이다.
​3) ​스케줄링 결정이나 프로시저 동기화를 위해 커널을 호출하지 않는다. 시스템 호출과 같은 인터럽트가 발생 할 때 오버헤드가 발생하는데 커널에 의존해야 하는 스레드보다 오버헤드가 적다.
​

### 1.2. 단점
​1) ​커널이 멀티스레드 프로세스를 한 스레드로 간주한다는데 있다.
규모를 확장하기 어렵다. 커널이 한 프로세스에 속한 스레드들을 여러 프로세서에 동시에 할당할 수 없기 때문이다.
​2) ​멀티프로세서 시스템에서는 사용자 수준 스레드가 차선의 성능만 낼 뿐이다. 다대일 스레드 맵핑에서는 프로세스에 속한 스레드 중 어느 하나만 입출력 작업을 위해 블록되어도 프로세스 전체가 블록된다. 운영체제에서 여러 스레드를 포함하는 프로세스를 프로그램 제어 흐름의 한 스레드로 인식하기 때문이다. 해당 프로세스가 준비 상태에 있는 스레드를 많이 포함하더라도 블록 스레드가 준비 상태가 될 때까지는 이들 중 어떤 스레드도 실행하지 못한다. 따라서 멀티스레드 프로세스에 블록이 빈번히 일어나면 전체적인 진행이 느려진다.
​3) ​사용자 수준 스레드는 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다.

## 2. 커널 수준 스레드
​각 스레드마다 고유한 실행 문맥을 맵핑하는 방법으로 사용자 수준 스레드의 한계를 해결하려고 한다.
​일대일 스레드 맵핑(one-to-one thread mapping)​이라고 표현한다.
​스레드를 일대일 맵핑하려면 운영체제에서 디스패치할 수 있는 커널 스레드를 각 사용자 스레드에 제공해야 한다.

### 2-1. 장점
​1) 커널은 프로세스의 스레드들을 몇몇 프로세서에 한꺼번에 디스패치할 수 있기 때문에 병렬 실행하도록 설계된 응용 프로그램의 성능을 높여준다.​
​2) ​커널이 각 스레드를 개별적으로 관리할 수 있다.
​3) ​응용 프로그램은 입출력 작업이 끝날 때까지 다른 스레드를 사용해 다른 작업을 진행할 수 있다.
​4) ​사용자 입력에 빨리 반응할 수 있게 해서 응용 프로그램의 상호 작용성을 높여준다.
 
운영체제 디스패치는 커널 수준 스레드를 통해 사용자 스레드를 개별적으로 인식할 수 있다.
우선순위 지정을 통한 서비스의 수준을 조절할 수 있다.

### 2-2. 단점
1) ​스케줄링과 동기화를 위해 커널을 호출해야 하는데, 이는 오버헤드를 증가시킨다.
​2) ​커널 수준 스레드를 사용하는 소프트웨어는 사용자 수준 스레드를 사용할 때보다 이식성이 떨어진다.
​3) ​커널 수준 스레드를 사용하는 응용 프로그램 프로그래머는 실행될 시스템이 달라지면 해당 운영체제에서 제공하는 스레드 API를 사용해 프로그램을 수정해야한다.
​4) ​자원을 더 많이 소비하는 경향이 있다.

## ​​3. 사용자 수준의 스레드와 커널 수준 스레드의 조합
​다대다 스레드 맵핑(many-to-many thread mapping)​이라고 한다.
​많은 사용자 수준 스레드를 한 그룹의 커널 스레드에 맵핑한다.​​
​m대n 스레드 맵핑(m-to-n thread mapping)​이라고도 한다.
​
일대일 스레드 맵핑을 하려면 운영체제가 커널 스레드를 나타내는 자료 구조를 할당해야 한다.
시스템의 스레드가 증가함에 따라 커널 스레드에서 소비하는 자료 구조의 용량이 크게 늘어난다.
다대다 스레드 맵핑은 ​스레드 풀링(thread pooling)​을 통해 이 오버헤드 문제를 해결한다.

### 3-1. 장점
응용 프로그램들이 스레딩 라이브러리의 스케줄링 알고리즘을 필요에 맞게 커스터마이즈해 성능을 향상시킬수 있다.

### 3-2. 단점
1) 한 사용자 수준 스레드가 블록되면 운영체제가 멀티스레드 프로세스 전체를 블록한다.
​2) 멀티프로세서에서도 프로세스의 스레드들을 동시에 실행할 수 없다.​
​이는 ​스케줄러 활성화(scheduler activation)​로 해결하는데 이는 사용자 수준 스레드 라이브러리에 이벤트 발생을 알리는 커널 스레드이다.
​이런 형태의 커널 스레드를 '스케줄러 활성화'라고 하는데, 이벤트 통지를 통해 '활성화' 되었을 때 사용자 수준 스레드 라이브러리가 스레드 스케줄링을 수행할 수 있기 때문이다.
​
​
​운영체제는 멀티스레드 프로세스가 생성될 때 프로세스의 사용자 수준 스레드 라이브러리의 초기화 코드를 수행하는 스케줄러 활성화를 생성한다.
이는 스레드를 생성하고 필요하면 스레드에 필요한 추가적인 프로세서를 요청한다.
​
​
운영체제는 사용자 수준 스레드가 블록되면 스레드의 상태를 해당 스케줄러 활성화에 저장하고, 새로운 스케줄러 활성화를 생성해 사용자 수준 라이브러리에 자신의 스레드 중 하나가 블록되었음을 알려준다. 그러면 사용자 수준 스레드 라이브러리는 스케줄러 활성화로부터 블록된 스레드의 상태를 저장하고, 해당 스케줄러 활성화에 다른 스레드를 할당한다. 이러한 메커니즘으로 한 스레드만 블록되어도 멀티스레드 프로세스 전체가 블록되는 현상을 방지할 수 있다.
​
다대다 스레딩 모델의 중요한 단점은
운영체제 설계가 복잡해지고 구현에 대한 표준적인 방법이 없다는 점이다.