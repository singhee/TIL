# l-value vs r-value

`l-value` 는 지속성이 있는 값이고, `r-value` 는 지속성이 없는 값을 의미한다. 또는 `l-value` 는 수식에서 identity 를 가지는 value 를 의미하며, `r-value` 는 identity 를 가지지 않는 값을 의미한다. 다시 말하면, 주소를 취할 수 있으면 `l-value`, 취할 수 없으면 `r-value` 이다.

	"Every expression is either an lvalue or an rvalue" 
	모든 표현식은 l-value 나 r-value 를 가진다. 

`l-value` 로 선언된 Object 는 단일 표현식을 넘어서도 존재하게 된다. 예를들어, obj, *ptr, ptr[index], ++x 들은 `l-value` 이다.
`r-value` 는 임시적으로 표현식이 끝나면 없어지는 값들로 1729,  x + y, x++ 들을 예로 들 수 있다.

 여기서 `++x` 와 `x++` 의 차이점을 알아야 한다. int x = 0 으로 선언된 x 가 있으면, x는 `l-value` 이고, 지속성있는 객체 이다.
 `++x` 도 `l-value` 가 된다. 값을 증가 시키고 지속성있는 객체로 이름을 붙이기 때문이다.
 하지만, `x++` 은 `r-value` 이다. `x++` 은 지속성있는 객체의 원래 값을 복사하고, 지속성 있는 개체의 값을 증가 시키고 복사된 값을 리턴하는 동작을 하기 때문이다. `++x` 와 `x++` 둘 다 x의 값을 증가 시키지만, `++x` 는 지속성 있는 객체 자신을 리턴 하지만 `x++` 은 임시적인 복사본을 리턴한다. 

 `r-value` 와 `l-value` 를 직관적으로 구분하기 위해서는 표현식에서 값의 주소를 가지고 있는지를 알아 보면 `l-value` 인지 아닌지 알 수 있다. 만약, 값의 주소를 알 수 있다면 그 값은 `l-value` 이다. 주소연산자(`&`)에서 피연산자는 `l-value` 이기 때문에 주소 연산자를 통해 확인하면 된다.