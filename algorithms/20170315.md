# 20170315 : Algorithms (자료구조1 - 스택, 큐, 덱, 문자열) 

## Stack
스택은 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 자료구조로 Last In First Out(LIFO)라고도 한다.  스택은 C++의 경우에는 STL의 stack,  Java의 경우에는 Java.util.Stack 을 사용하는 것이 좋다. 

### 올바른 괄호 문자열 찾기
### 쇠막대기
### 에디터

## Queue
큐는 한쪽 끝에서만 자료를 넣고 다른 한쪽 끝에서만 뺄 수 있는 자료구조로 First In First Out(FIFO)라고도 한다.  큐는 C++의 경우에는 STL의 queue,  Java의 경우에는 Java.util.Queue 을 사용하는 것이 좋다. 

큐를 배열을 통해 구현할 때 가장 중요한 두 가지 요소는 자료의 시작 index와 (begin), 자료 끝 바로 다음 index이다 (end). 

### 조세퍼스 문제 
N 명의 사람들이 원을 이루면서 앉아있고, 주어진 양의 정수 M(<= N) 번째 사람들을 N명의 사람들이 모두 제거될 때까지 제거한다. 이렇게 원에서 제거되는 순서를 (N,M) - 조세퍼스 순열 이라고 한다. 

## Deck (Double-ended queue)
덱은 양 끝에서만  자료를 넣고 양 끝에서 뺄 수 있는 자료구조이다.  덱의 특징을 이용해서 푸는 문제는 많지 않다. 

## 문자열
문자열은 아스키 코드를 이용해서 저장을 하게 된다. (Ex. ‘0’ => 48, ‘A’ => 65, ‘a’ => 97,  NULL => 0 (숫자))

### 단어 길이 재기
C++ 이나 Java와 같은 경우는 strlen 이나 string의 length 또는 size 를 이용하면 된다. 그렇지 않으면, 다음과 같이 길이를 잴 수 있다. 

```c
scanf("%s", s)
int len = 0;
for(int i = 0; s[i]; i++) { 
	len += 1;
}
printg("%d\n", len);
```

C언어 에서의 문자열의 마지막에는 ‘\0’ (널문자)가  들어가기 때문에, 위의 3번 째 줄 코드에서의 s[i] 는 Null을 의미하며, Null 을 만날 때 해당 for루프를 탈출하며 길이를 잴 수 있게 된다 . 이 방법은  `strlen()`함수를 쓰지 않아도 되기 때문에 매우 많이 쓰이는 방법인데, 그 이유는 다음과 같은 이유에서이다. 

```c 
for(int i = 0; i<strlen(s); i++) {  // O(N^2)
	// Do Something
}
```
 `strlen()` 함수의 시간 복잡도는 O(N)이기 때문에 위와 같이 for 루프에서 매번 `strlen()`을 호출하는 코드를 작성하게 된다면 위의 전체적인 시간복잡도는 O(N^2)이 된다. 
그러기 때문에  `strlen()`을 처음에 한번만 호출해 주면, O(N)의 시간 복잡도로 문자열을 모두 순회할 수 있는 코드를 작성할 수 있다. 

```c 
int len = strlen(s);
for(int i = 0; i<len; i++) {	// O(N)
	// Do Something
}
``` 

### 문자열 -> 정수
C++ 에서 문자열을 정수로 바꾸려면  `stoi, stol, stoll` 등등의 함수를 사용하면 된다. 여기서 sto 는 string to 의 약자를 의미하며, 그 뒤는 바꾸고자 하는 타입을 의미한다.  (ex. stoi -> string to int)  
이 함수들을 사용하려면  `#include<string>`을 통해 사용가능하다. 

> 정수를 문자열로 바꾸고 싶다면?
> `to_string`함수를 사용하면 된다.  이는 정수 뿐만 아니라 실수 타입의 자료형에도 해당된다. 
