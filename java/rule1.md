# 규칙1. 생성자 대신 정적 팩터리 메소드를 사용할 수 없는지 생각해 보라

클래스를 통해 객체를 만드는 일반적인 방법은 `public` 으로 선언된 생성자(constructure)을 이용하는 것이다. 그러나 모든 프로그래머가 반드시 알고 있어야 하는 방법이 하나 더 있다. 클래스에 `public`으로 선언된 `정적 팩터리 메소드(static factory method)` 를 추가하는 것이다. 아래의 메소드는 Boolean 클래스에 대한 예로 기본 타입 boolean 의 값을 Boolean 객체에 대한 `참조(reference)` 로 변환한다.
```java
public static Boolean valueOf(boolean b){
	return b ? Boolean.TRUE : Boolean.FALSE;
}
```
이것은 `팩터리 메소드(Factory Method)` 와는 개념이 다르다는 점에 유의하자.

클래스를 정의할 때 생성자 대신 `정적 팩터리 메소드`를 제공할 수 있다. `public` 으로 선언된 생성자 대신 `정적 팩토리 메소드`를 제공하는 방법의 장단점은 다음과 같다.

#### # 정적 팩토리 메소드의 장점 1. 생성자와는 달리 정적 팩터리 메소드에는 이름(name)이 있다.
생성자에 전달되는 인자(parameter)들은 어떤 객체가 생성되는지를 설명하지 못한다. 하지만, 정적 팩터리 메소드는 이름을 잘 짓기만 한다면 사용하기도 쉽고 클라이언트 코드의 가독성(readability)을 높여준다.
>예를들어, 소수(prime)일 가능성이 높은 BigInteger 객체를 생성하는 생성자 BigInteger(int, int, Raandom)은 BigInteger.probablePrime 과 같은 이름의 정적 팩터리 메소드로 표현했으면 더 이해하기 쉬웠을 것이다. 

클래스에는 시그니처(signature)별로 하나의 생성자만을 넣을 수 있다. 이 제약을 피하는 방법은 인자의 순서를 바꾸는 것이다. 하지만 이 방법을 사용하는 사용자는 각각의 생성자 용도를 절대로 기억하지 못할 것이며, 결국 실수로 엉뚱한 생성자를 호출하게 될 것이다. 이런 생성자를 사용하는 코드를 읽는 사람은 API 설명서를 참조하지 않고서는 코드가 하는 일을 제대로 파악하지 못할 것이다.
반면, 정적 팩터리 메소드에는 이름이 있으므로 그런 문제는 생기지 않는다. 그러니 같은 signature를 갖는 생성자를 여러 개 정의할 필요가 있을 때에는 그 생성자들을 정적 팩터리 메소드로 바꾸고, 메소드 이름을 보면 차이가 명확히 드러나도록 작명에 신경 쓰는 것이다.



#### # 정적 팩토리 메소드의 장점 2. 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.
앞서 살펴본 `Boolean.valueOf(Boolean)` 메소드는 이미 만들어 둔 객체를 활용하거나, 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수 있다. 결코 객체를 생성하지 않는 것이다. 이 기법은 `경량(Flyweight)패턴`과 유사하다. 동일한 객체가 요청되는 일이 잦고, 특히 객체를 만드는 비용이 클 때 적용하면 성능을 개선할 수 있다.
정적 팩터리 메소드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. 그런 기능을 갖춘 클래스는 `개체 통제 클래스(instance-controlled class)`라 부른다. 개체 통제 클래스를 작성하는 이유는 몇 가지가 있다.
> 1. 싱글톤(singleton)패턴을 따르도록 할 수 있다. (Effective Java 규칙.3)
  2. 객체 생성이 불가능한 클래스를 만들 수 있다. (Effective Java 규칙.4)
  3. 변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수 있다. (Effective Java 규칙.15)

#### # 정적 팩토리 메소드의 장점 3. 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
이는 반환되는 객체의 클래스를 유연하게 결정할 수 있다. 이 유연성을 활용하면 `public`으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. 그러면 구현 세부사항을 감출 수 있으므로 아주 간결한 API가 가능해진다. 이 기법은 `인터페이스 기반 프레임워크(interface-based framework)`구현에 적합한데, 이 프레임워크에서 인터페이스는 정적 팩터리 메소드의 반환값 자료형으로 이용된다. 인터페이스는 정적 메소드를 가질 수 없으므로, 관습상 반환값 자료형이 `Type`이라는 이름의 인터페이스인 정적 팩터리 메소드는 `Types`라는 이름의 `객체 생성 불가능(noninstantiable)` 클래스안에 둔다. (Effective Java 규칙.4)
> 예를 들어, 자바의 컬렉션 프레임워크(Collection Framework)에는 32개의 컬렉션 인터페이스 구현체(implementation)가 들어있는데, 변경이 불가능한 컬렉션과 동기화된(synchronized) 컬렉션 등이다. 이 구현체들 거의 전부는 java.util.Collections라는 객체 생성 불가능 클래스의 정적 팩터리 메소드를 통해 이용하는데, 반환되는 객체의 실제 클래스는 public 이 아니다.  
-> 구현체별로 32개의 public 클래스를 만들었다면 컬렉션 프레임워크 API의 규모는 더 커졌을 것이다. 

API 사용자는 반환된 객체가 인터페이스에 규정된 내용을 정확하게 따른다는 사실을 알고 있다. 따라서 별도의 클래스 사용법 문서를 읽지 않아도 그 구현체를 이용할 수 있다. 


























