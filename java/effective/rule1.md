# 규칙1. 생성자 대신 정적 팩토리 메소드를 사용할 수 없는지 생각해 보라

클래스를 통해 객체를 만드는 일반적인 방법은 `public` 으로 선언된 생성자(constructure)을 이용하는 것이다. 그러나 모든 프로그래머가 반드시 알고 있어야 하는 방법이 하나 더 있다. 클래스에 `public`으로 선언된 `정적 팩토리 메소드(static factory method)` 를 추가하는 것이다. 아래의 메소드는 Boolean 클래스에 대한 예로 기본 타입 boolean 의 값을 Boolean 객체에 대한 `참조(reference)` 로 변환한다.
```java
public static Boolean valueOf(boolean b){
	return b ? Boolean.TRUE : Boolean.FALSE;
}
```
이것은 `팩토리 메소드(Factory Method)` 와는 개념이 다르다는 점에 유의하자.

클래스를 정의할 때 생성자 대신 `정적 팩토리 메소드`를 제공할 수 있다. `public` 으로 선언된 생성자 대신 `정적 팩토리 메소드`를 제공하는 방법의 장단점은 다음과 같다.

#### # 정적 팩토리 메소드의 장점 1. 생성자와는 달리 정적 팩토리 메소드에는 이름(name)이 있다.
생성자에 전달되는 인자(parameter)들은 어떤 객체가 생성되는지를 설명하지 못한다. 하지만, 정적 팩토리 메소드는 이름을 잘 짓기만 한다면 사용하기도 쉽고 클라이언트 코드의 가독성(readability)을 높여준다.
>예를들어, 소수(prime)일 가능성이 높은 BigInteger 객체를 생성하는 생성자 BigInteger(int, int, Raandom)은 BigInteger.probablePrime 과 같은 이름의 정적 팩토리 메소드로 표현했으면 더 이해하기 쉬웠을 것이다. 

클래스에는 시그니처(signature)별로 하나의 생성자만을 넣을 수 있다. 이 제약을 피하는 방법은 인자의 순서를 바꾸는 것이다. 하지만 이 방법을 사용하는 사용자는 각각의 생성자 용도를 절대로 기억하지 못할 것이며, 결국 실수로 엉뚱한 생성자를 호출하게 될 것이다. 이런 생성자를 사용하는 코드를 읽는 사람은 API 설명서를 참조하지 않고서는 코드가 하는 일을 제대로 파악하지 못할 것이다.
반면, 정적 팩토리 메소드에는 이름이 있으므로 그런 문제는 생기지 않는다. 그러니 같은 signature를 갖는 생성자를 여러 개 정의할 필요가 있을 때에는 그 생성자들을 정적 팩토리 메소드로 바꾸고, 메소드 이름을 보면 차이가 명확히 드러나도록 작명에 신경 쓰는 것이다.



#### # 정적 팩토리 메소드의 장점 2. 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.
앞서 살펴본 `Boolean.valueOf(Boolean)` 메소드는 이미 만들어 둔 객체를 활용하거나, 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수 있다. 결코 객체를 생성하지 않는 것이다. 이 기법은 `경량(Flyweight)패턴`과 유사하다. 동일한 객체가 요청되는 일이 잦고, 특히 객체를 만드는 비용이 클 때 적용하면 성능을 개선할 수 있다.
정적 팩토리 메소드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. 그런 기능을 갖춘 클래스는 `개체 통제 클래스(instance-controlled class)`라 부른다. 개체 통제 클래스를 작성하는 이유는 몇 가지가 있다.
> 
1. 싱글톤(singleton)패턴을 따르도록 할 수 있다. (Effective Java 규칙.3)
2. 객체 생성이 불가능한 클래스를 만들 수 있다. (Effective Java 규칙.4)
3. 변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수 있다. (Effective Java 규칙.15)

#### # 정적 팩토리 메소드의 장점 3. 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
이는 반환되는 객체의 클래스를 유연하게 결정할 수 있다. 이 유연성을 활용하면 `public`으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. 그러면 구현 세부사항을 감출 수 있으므로 아주 간결한 API가 가능해진다. 이 기법은 `인터페이스 기반 프레임워크(interface-based framework)`구현에 적합한데, 이 프레임워크에서 인터페이스는 정적 팩토리 메소드의 반환값 자료형으로 이용된다. 인터페이스는 정적 메소드를 가질 수 없으므로, 관습상 반환값 자료형이 `Type`이라는 이름의 인터페이스인 정적 팩토리 메소드는 `Types`라는 이름의 `객체 생성 불가능(noninstantiable)` 클래스안에 둔다. (Effective Java 규칙.4)
> 예를 들어, 자바의 컬렉션 프레임워크(Collection Framework)에는 32개의 컬렉션 인터페이스 구현체(implementation)가 들어있는데, 변경이 불가능한 컬렉션과 동기화된(synchronized) 컬렉션 등이다. 이 구현체들 거의 전부는 java.util.Collections라는 객체 생성 불가능 클래스의 정적 팩토리 메소드를 통해 이용하는데, 반환되는 객체의 실제 클래스는 public 이 아니다.  
-> 구현체별로 32개의 public 클래스를 만들었다면 컬렉션 프레임워크 API의 규모는 더 커졌을 것이다. 

API 사용자는 반환된 객체가 인터페이스에 규정된 내용을 정확하게 따른다는 사실을 알고 있다. 따라서 별도의 클래스 사용법 문서를 읽지 않아도 그 구현체를 이용할 수 있다. 


#### # 정적 팩토리 메소드의 장점 4. 형인자 자료형(parameterized type)객체를 만들 때 편하다.
```java
Map<String, List<String>> m = new HashMap<String, List<String>>();
```
위의 코드처럼 자료형 명세를 중복하면, 형인자가 늘어남에 따라 길고 복잡한 코드가 만들어진다. 하지만, 정적 팩토리 메소드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다. 이러한 기법을 **자료형 유추(type inference)**라고 한다. 예를 들어, HashMap 클래스가 아래의 제네릭 정적 팩토리 메소드를 제공한다고 가정해 보자.

```java
public static <K, V> HashMap<K, V> newInstance(){
	return new HashMap<K, V>();
}
```
이런 메소드가 있으면 위의 자료형 명세 중복으로 인한 복잡한 코드를 좀 더 간결하게 작성할 수 있다.
```java
Map<String, List<String>> m = HashMap.newInstance();
```
불행히도, HashMap과 같은 표준 컬렉션 라이브러리는 JDK 1.6까지는 팩토리 메소드를 제공하지 않고 있다. 하지만 형인자 유틸리티 클래스(parameterized utility class)안에 정적 팩토리 메소드를 넣어두면 된다.

정적 팩토리 메소드만 있는 클래스를 만들면 생기는 문제점이 두 가지 있다.
첫 번째 문제는, **public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.** public 정적 팩토리 메소드가 반환하는 비-public 클래스도 마찬가지다. 두 번째 문제는, **정적 팩토리 메소드가 다른 정적 메소드와 확연히 구분되지 않는다는 것이다.** API 문서를 보면 생성자는 다른 메소드와 뚜렷이 구별되지만, 정적 팩처리 메소드는 그렇지 않다. 그러기 때문에 생성자 대신 정적 팩토리 메소드를 통해 객체를 만들어야 하는 클래스는 사용법을 파악하기가 쉽지 않다. 지금으로서는 클래스나 인터페이스 주석(comment)를 통해 정적 팩토리 메소드임을 널리 알리거나, 정적 팩토리 메소드 이름을 지을 때 조심하는 수밖에 없다.

정적 팩토리 메소드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점에 대해 아는것이 중요하다. 정적 팩토리 메소드가 효과적인 경우가 많으니, 정적 팩토리 메소드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가기 바란다.










